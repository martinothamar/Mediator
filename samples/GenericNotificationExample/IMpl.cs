// <auto-generated>
//     Generated by the Mediator source generator.
// </auto-generated>

#pragma warning disable CS8019 // Unused usings

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.Linq;

using SD = global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// DI extensions for Mediator.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    public static class MediatorDependencyInjectionExtensions
    {
        /// <summary>
        /// Adds the Mediator implementation and handlers of your application.
        /// </summary>
        public static IServiceCollection AddMediator(this IServiceCollection services)
        {
            return AddMediator(services, null);
        }

        internal sealed class Dummy { }

        /// <summary>
        /// Adds the Mediator implementation and handlers of your application, with specified options.
        /// </summary>
        public static IServiceCollection AddMediator(this IServiceCollection services, global::System.Action<global::Mediator.MediatorOptions> options)
        {
            services.Add(new SD(typeof(global::Mediator.Mediator), typeof(global::Mediator.Mediator), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));
            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));
            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));
            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::Mediator.Mediator>(), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));

            services.TryAdd(new SD(typeof(global::PingHandler), typeof(global::PingHandler), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));
            services.Add(new SD(
                typeof(global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>),
                sp =>
                {
                    return new global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>(
                        sp.GetRequiredService<global::PingHandler>(),
                        sp.GetServices<global::Mediator.IPipelineBehavior<global::Ping, global::Pong>>()
                    );
                },
                global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped
            ));



            services.Add(new SD(typeof(global::Mediator.INotificationHandler<>), typeof(global::PostRequestHandler<>), global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped));

            services.AddSingleton<Dummy>();

            return services;

            [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
            static global::System.Func<global::System.IServiceProvider, T> GetRequiredService<T>() where T : notnull => sp => sp.GetRequiredService<T>();
        }
    }
}

namespace Mediator
{
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class RequestClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.IRequest<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public RequestClassHandlerWrapper(
            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class RequestStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.IRequest<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public RequestStructHandlerWrapper(
            global::Mediator.IRequestHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamRequestClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.IStreamRequest<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamRequestClassHandlerWrapper(
            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamRequestStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.IStreamRequest<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamRequestStructHandlerWrapper(
            global::Mediator.IStreamRequestHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class CommandClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.ICommand<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public CommandClassHandlerWrapper(
            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class CommandStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.ICommand<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public CommandStructHandlerWrapper(
            global::Mediator.ICommandHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamCommandClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.IStreamCommand<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamCommandClassHandlerWrapper(
            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamCommandStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.IStreamCommand<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamCommandStructHandlerWrapper(
            global::Mediator.IStreamCommandHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class QueryClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.IQuery<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public QueryClassHandlerWrapper(
            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class QueryStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.IQuery<TResponse>
    {
        private readonly global::Mediator.MessageHandlerDelegate<TRequest, TResponse> _rootHandler;

        public QueryStructHandlerWrapper(
            global::Mediator.IQueryHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.MessageHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamQueryClassHandlerWrapper<TRequest, TResponse>
        where TRequest : class, global::Mediator.IStreamQuery<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamQueryClassHandlerWrapper(
            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    internal sealed class StreamQueryStructHandlerWrapper<TRequest, TResponse>
        where TRequest : struct, global::Mediator.IStreamQuery<TResponse>
    {
        private readonly global::Mediator.StreamHandlerDelegate<TRequest, TResponse> _rootHandler;

        public StreamQueryStructHandlerWrapper(
            global::Mediator.IStreamQueryHandler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<global::Mediator.IStreamPipelineBehavior<TRequest, TResponse>> pipelineBehaviours
        )
        {
            var handler = (global::Mediator.StreamHandlerDelegate<TRequest, TResponse>)concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }

    /// <summary>
    /// Generated code for Mediator implementation.
    /// This type is also registered as a DI service.
    /// Can be used directly for high performance scenarios.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "2.1.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.Diagnostics.DebuggerStepThroughAttribute]
    public sealed partial class Mediator : global::Mediator.IMediator, global::Mediator.ISender, global::Mediator.IPublisher
    {
        private readonly global::System.IServiceProvider _sp;
        private DICache _diCache;

        /// <summary>
        /// The lifetime of Mediator-related service registrations in DI container.
        /// </summary>
        public static global::Microsoft.Extensions.DependencyInjection.ServiceLifetime ServiceLifetime { get; } = global::Microsoft.Extensions.DependencyInjection.ServiceLifetime.Scoped;

        private readonly global::System.Func<global::System.Collections.Generic.IEnumerable<object>, int> _getServicesLength;

        /// <summary>
        /// Constructor for DI, should not be used by consumer.
        /// </summary>
        public Mediator(global::System.IServiceProvider sp)
        {
            _sp = sp;
            _diCache = new DICache(_sp);

            _getServicesLength = sp.GetServices<global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy>() is global::Microsoft.Extensions.DependencyInjection.MediatorDependencyInjectionExtensions.Dummy[]? (s => ((object[])s).Length) : (s => s.Count());
        }


        private readonly struct DICache
        {
            private readonly global::System.IServiceProvider _sp;

            public global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong> Wrapper_For_Ping
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get => _sp.GetRequiredService<global::Mediator.RequestClassHandlerWrapper<global::Ping, global::Pong>>();
            }
            public global::System.Collections.Generic.IEnumerable<global::Mediator.INotificationHandler<global::PostRequest<TRequest>>> Handlers_For_PostRequest<TRequest>()
                where TRequest : IBaseRequest =>
                _sp.GetServices<global::Mediator.INotificationHandler<global::PostRequest<TRequest>>>();

            public DICache(global::System.IServiceProvider sp)
            {
                _sp = sp;

            }
        }

        /// <summary>
        /// Send a message of type global::Ping.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<global::Pong> Send(
            global::Ping message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowIfNull(message, nameof(message));

            return _diCache.Wrapper_For_Ping.Handle(message, cancellationToken);
        }

        /// <summary>
        /// Send request.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming request</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            switch (request)
            {
                case global::Ping r:
                    {
                        var task = Send(r, cancellationToken);
                        return global::System.Runtime.CompilerServices.Unsafe.As<global::System.Threading.Tasks.ValueTask<global::Pong>, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                    }
                default:
                    {
                        ThrowArgumentNullOrInvalidMessage(request, nameof(request));
                        return default;
                    }
            }

        }

        /// <summary>
        /// Create stream for request.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(request);
            return default;

        }

        /// <summary>
        /// Send command.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming command</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.ICommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(command);
            return default;

        }

        /// <summary>
        /// Create stream for command.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamCommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(command);
            return default;

        }

        /// <summary>
        /// Send query.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming query</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(query);
            return default;

        }

        /// <summary>
        /// Create stream for query.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(query);
            return default;

        }

        /// <summary>
        /// Send message.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public async global::System.Threading.Tasks.ValueTask<object> Send(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            switch (message)
            {
                case global::Ping m: return await Send(m, cancellationToken);
                default:
                    {
                        ThrowArgumentNullOrInvalidMessage(message as global::Mediator.IMessage, nameof(message));
                        return default;
                    }
            }

        }

        /// <summary>
        /// Create stream.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<object> CreateStream(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            ThrowInvalidMessage(message as global::Mediator.IStreamMessage);
            return default;

        }

        /// <summary>
        /// Publish notification.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish(
            object notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            switch (notification)
            {
                case global::PostRequest<TRequest> n: return Publish(n, cancellationToken);
                default:
                    {
                        ThrowIfNull(notification, nameof(notification));
                        return default;
                    }
            }

        }

        /// <summary>
        /// Send a notification of type global::PostRequest<TRequest>.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// </summary>
        /// <param name="notification">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish<TRequest>(
            global::PostRequest<TRequest> notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
            where TRequest : IBaseRequest
        {
            ThrowIfNull(notification, nameof(notification));

            var handlers = _diCache.Handlers_For_PostRequest<TRequest>();

            if (handlers is global::Mediator.INotificationHandler<global::PostRequest<TRequest>>[] handlersArray)
            {
                if (handlersArray.Length == 0)
                {
                    return default;
                }
                else if (handlersArray.Length == 1)
                {
                    return handlersArray[0].Handle(notification, cancellationToken);
                }

                return PublishArr(notification, handlersArray, cancellationToken);
            }
            else
            {
                int count = 0;
                if (handlers == null || (count = _getServicesLength(handlers)) == 0)
                {
                    return default;
                }
                else if (count == 1)
                {
                    return handlers.First().Handle(notification, cancellationToken);
                }

                return Publish(notification, handlers, cancellationToken);
            }

            async global::System.Threading.Tasks.ValueTask Publish(global::PostRequest<TRequest> notification, global::System.Collections.Generic.IEnumerable<global::Mediator.INotificationHandler<global::PostRequest<TRequest>>> handlers, global::System.Threading.CancellationToken cancellationToken)
            {
                // We don't allocate the list if no task throws
                global::System.Collections.Generic.List<global::System.Exception> exceptions = null;

                foreach (var handler in handlers)
                {
                    try
                    {
                        await handler.Handle(notification, cancellationToken).ConfigureAwait(false);
                    }
                    catch (global::System.Exception ex)
                    {
                        exceptions ??= new global::System.Collections.Generic.List<global::System.Exception>();
                        exceptions.Add(ex);
                    }
                }

                MaybeThrowAggregateException(exceptions);
            }
            async global::System.Threading.Tasks.ValueTask PublishArr(global::PostRequest<TRequest> notification, global::Mediator.INotificationHandler<global::PostRequest<TRequest>>[] handlers, global::System.Threading.CancellationToken cancellationToken)
            {
                // We don't allocate the list if no task throws
                global::System.Collections.Generic.List<global::System.Exception> exceptions = null;

                for (int i = 0; i < handlers.Length; i++)
                {
                    try
                    {
                        await handlers[i].Handle(notification, cancellationToken).ConfigureAwait(false);
                    }
                    catch (global::System.Exception ex)
                    {
                        exceptions ??= new global::System.Collections.Generic.List<global::System.Exception>();
                        exceptions.Add(ex);
                    }
                }

                MaybeThrowAggregateException(exceptions);
            }
        }

        /// <summary>
        /// Publish notification.
        /// Throws <see cref="global::System.ArgumentNullException"/> if message is null.
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(
            TNotification notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
            where TNotification : global::Mediator.INotification
        {
            switch (notification)
            {
                case global::PostRequest<TRequest> n: return Publish(n, cancellationToken);
                default:
                    {
                        ThrowIfNull(notification, nameof(notification));
                        return default;
                    }
            }

        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidMessage(object msg) =>
            throw new global::Mediator.MissingMessageHandlerException(msg);

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowArgumentNull(string paramName) =>
            throw new global::System.ArgumentNullException(paramName);

        private static void ThrowIfNull<T>(T argument, string paramName)
        {
            if (argument is null)
            {
                ThrowArgumentNull(paramName);
            }
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowArgumentNullOrInvalidMessage(object msg, string paramName)
        {
            if (msg is null)
            {
                ThrowArgumentNull(paramName);
            }
            else
            {
                ThrowInvalidMessage(msg);
            }
        }

        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions) =>
            throw new global::System.AggregateException(exceptions);

        private static void MaybeThrowAggregateException(global::System.Collections.Generic.List<global::System.Exception> exceptions)
        {
            if (exceptions is not null)
            {
                ThrowAggregateException(exceptions);
            }
        }
    }
}
