// <auto-generated>
//     Generated by the Mediator source generator.
// </auto-generated>

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.Linq;

namespace {{ MediatorNamespace }}
{
    /// <summary>
    /// DI extensions for Mediator.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    public static class DependencyInjectionExtensions
    {
        /// <summary>
        /// Adds the Mediator implementation and handlers of your application.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static IServiceCollection AddMediator(this IServiceCollection services)
        {
            services.TryAddSingleton<global::{{ MediatorNamespace }}.IMediator, global::{{ MediatorNamespace }}.MediatorImpl>();
            services.TryAddSingleton<global::Mediator.ISender>(sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.IMediator>());
            services.TryAddSingleton<global::Mediator.IPublisher>(sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.IMediator>());

            {{~ for handler in Handlers ~}}
            services.TryAddSingleton<{{ handler.FullName }}, {{ handler.FullName }}>();
            {{~ end ~}}

            {{~ for handlerInterface in InterfaceHandlers ~}}
            {{~ for handler in handlerInterface.ConcreteHandlers ~}}
            {{- if handlerInterface.IsNotificationType }}
            services.AddSingleton<{{ handlerInterface.FullName }}>(sp => sp.GetRequiredService<{{ handler.FullName }}>());
            {{- else }}
            services.AddSingleton<{{ handlerInterface.FullName }}>(sp =>
            {
                var concreteHandler = sp.GetRequiredService<{{ handler.FullName }}>();
                {{- if handlerInterface.HasResponse }}
                var pipelineBehaviors = sp.GetServices<global::Mediator.IPipelineBehavior<{{ handlerInterface.RequestType.FullName }}, {{ handlerInterface.ResponseType.FullName }}>>();
                return new {{ handlerInterface.MessageType }}HandlerWrapper<{{ handlerInterface.RequestType.FullName }}, {{ handlerInterface.ResponseType.FullName }}>(
                    concreteHandler,
                    pipelineBehaviors
                );
                {{- else }}
                var pipelineBehaviors = sp.GetServices<global::Mediator.IPipelineBehavior<{{ handlerInterface.RequestType.FullName }}>>();
                return new {{ handlerInterface.MessageType }}HandlerWrapper<{{ handlerInterface.RequestType.FullName }}>(
                    concreteHandler,
                    pipelineBehaviors
                );
                {{- end }}

            });
            {{- end }}
            {{~ end ~}}
            {{~ end ~}}

            return services;
        }
        
        {{~ for handlerType in HandlerTypes ~}}
        {{ if handlerType.HasResponse }}
        private sealed class {{ handlerType.Name }}HandlerWrapper<T{{ handlerType.Name }}, TResponse> : global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}, TResponse>
            where T{{ handlerType.Name }} : global::Mediator.I{{ handlerType.Name }}<TResponse>
        {
            private readonly global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}, TResponse> _rootHandler;

            public {{ handlerType.Name }}HandlerWrapper(
                global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}, TResponse> concreteHandler,
                global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<T{{ handlerType.Name }}, TResponse>> pipelineBehaviours
            )
            {
                var handler = (global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}, TResponse>)concreteHandler.Handle;

                foreach (var pipeline in pipelineBehaviours.Reverse())
                {
                    var handlerCopy = handler;
                    var pipelineCopy = pipeline;
                    handler = (T{{ handlerType.Name }} message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
                }

                _rootHandler = handler;
            }

            public global::System.Threading.Tasks.ValueTask<TResponse> Handle(T{{ handlerType.Name }} {{ string.downcase handlerType.Name }}, global::System.Threading.CancellationToken cancellationToken)
            {
                return _rootHandler({{ string.downcase handlerType.Name }}, cancellationToken);
            }
        }
        {{ else if handlerType.IsNotificationType != true }}
        private sealed class {{ handlerType.Name }}HandlerWrapper<T{{ handlerType.Name }}> : global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}>
            where T{{ handlerType.Name }} : global::Mediator.I{{ handlerType.Name }}
        {
            private readonly global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}> _rootHandler;

            public {{ handlerType.Name }}HandlerWrapper(
                global::Mediator.I{{ handlerType.Name }}Handler<T{{ handlerType.Name }}> concreteHandler,
                global::System.Collections.Generic.IEnumerable<global::Mediator.IPipelineBehavior<T{{ handlerType.Name }}>> pipelineBehaviours
            )
            {
                var handler = (global::Mediator.MessageHandlerDelegate<T{{ handlerType.Name }}>)concreteHandler.Handle;

                foreach (var pipeline in pipelineBehaviours.Reverse())
                {
                    var handlerCopy = handler;
                    var pipelineCopy = pipeline;
                    handler = (T{{ handlerType.Name }} message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
                }

                _rootHandler = handler;
            }

            public global::System.Threading.Tasks.ValueTask Handle(T{{ handlerType.Name }} {{ string.downcase handlerType.Name }}, global::System.Threading.CancellationToken cancellationToken)
            {
                return _rootHandler({{ string.downcase handlerType.Name }}, cancellationToken);
            }
        }
        {{ end }}
        {{~ end ~}}
    }

    /// <summary>
    /// Interface for the mediator pattern implementation.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    public interface IMediator : global::Mediator.ISender, global::Mediator.IPublisher
    {
        {{~ for messageData in RequestTypes ~}}
        /// <summary>
        /// Message handler for {{ messageData.RequestType.FullName }}.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        {{ messageData.RequestType.AsyncReturnType }} {{ messageData.RequestType.AsyncMethodName }}({{ messageData.RequestType.FullName }} message, global::System.Threading.CancellationToken cancellationToken = default);
        {{~ end ~}}
    }
    
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "1.0.0.0")]
    internal sealed partial class MediatorImpl : global::{{ MediatorNamespace }}.IMediator, global::Mediator.ISender, global::Mediator.IPublisher
    {
        private readonly global::System.IServiceProvider _sp;

        public MediatorImpl(global::System.IServiceProvider sp)
        {
            _sp = sp;
        }
    

        /// <summary>
        /// DI cache for Mediator.
        /// </summary>
        private sealed class DICache
        {
            private readonly global::System.IServiceProvider _sp;

            public DICache(global::System.IServiceProvider sp)
            {
                _sp = sp;
            }
        }
        
        {{~ for messageData in RequestTypes ~}}
        public {{ messageData.RequestType.AsyncReturnType }} {{ messageData.RequestType.AsyncMethodName }}({{ messageData.RequestType.FullName }} message, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{ if messageData.IsNotification }}
            return Publish<{{ messageData.RequestType.FullName }}>(message, cancellationToken);
            {{ else }}
            return _sp.GetRequiredService<{{ messageData.SingleHandlerInterface.FullName }}>().Handle(message, cancellationToken);
            {{ end }}
        }
        {{~ end ~}}

        // ValueTask<TResponse> Send<TResponse>(IRequest<TResponse> request, CancellationToken cancellationToken = default);

        // ValueTask Send(IRequest request, CancellationToken cancellationToken = default);

        // ValueTask<TResponse> Send<TResponse>(ICommand<TResponse> command, CancellationToken cancellationToken = default);

        // ValueTask Send(ICommand command, CancellationToken cancellationToken = default);

        // ValueTask<TResponse> Send<TResponse>(IQuery<TResponse> query, CancellationToken cancellationToken = default);

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        [global::System.Diagnostics.CodeAnalysis.DoesNotReturn]
        private static void ThrowInvalidMessage<TMsg>(TMsg msg) =>
            throw new global::System.ArgumentException("Invalid message type: " + msg.GetType().Name);

        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(global::Mediator.IRequest<TResponse> request, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{- if HasRequestsWithReponse }}
            switch (request)
            {
                {{~ for messageData in RequestWithResponseTypes ~}}
                case {{ messageData.RequestType.FullName }} r:
                {
                    var task = Send(r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ messageData.RequestType.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(request);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(request);
            return default;
            {{ end }}
        }

        public global::System.Threading.Tasks.ValueTask Send(global::Mediator.IRequest request, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{- if HasRequestsWithoutReponse }}
            switch (request)
            {
                {{~ for messageData in RequestWithoutResponseTypes ~}}
                case {{ messageData.RequestType.FullName }} r:
                {
                    return Send(r, cancellationToken);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(request);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(request);
            return default;
            {{ end }}
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(global::Mediator.ICommand<TResponse> command, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{- if HasCommandsWithReponse }}
            switch (command)
            {
                {{~ for messageData in CommandWithResponseTypes ~}}
                case {{ messageData.RequestType.FullName }} r:
                {
                    var task = Send(r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ messageData.RequestType.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(command);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(command);
            return default;
            {{ end }}
        }

        public global::System.Threading.Tasks.ValueTask Send(global::Mediator.ICommand command, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{- if HasCommandsWithoutReponse }}
            switch (command)
            {
                {{~ for messageData in CommandWithoutResponseTypes ~}}
                case {{ messageData.RequestType.FullName }} r:
                {
                    return Send(r, cancellationToken);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(command);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(command);
            return default;
            {{ end }}
        }

        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(global::Mediator.IQuery<TResponse> query, global::System.Threading.CancellationToken cancellationToken = default)
        {
            {{- if HasQueriesWithResponse }}
            switch (query)
            {
                {{~ for messageData in QueryWithResponseTypes ~}}
                case {{ messageData.RequestType.FullName }} r:
                {
                    var task = Send(r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ messageData.RequestType.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(query);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(query);
            return default;
            {{ end }}
        }

        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(TNotification notification, global::System.Threading.CancellationToken cancellationToken = default)
            where TNotification : global::Mediator.INotification
        {
            var sp = _sp;

            var handlers = sp.GetServices<global::Mediator.INotificationHandler<TNotification>>();

            var count = handlers.Count();
            if (handlers == null || count == 0)
                return default;
            else if (count == 1)
                return handlers.First().Handle(notification, cancellationToken);

            return Publish(notification, handlers, cancellationToken);

            async global::System.Threading.Tasks.ValueTask Publish(TNotification notification, global::System.Collections.Generic.IEnumerable<global::Mediator.INotificationHandler<TNotification>> handlers, global::System.Threading.CancellationToken cancellationToken)
            {
                // We don't allocate the list if no task throws
                global::System.Collections.Generic.List<global::System.Exception> exceptions = null;

                foreach (var handler in handlers)
                {
                    try
                    {
                        await handler.Handle(notification, cancellationToken).ConfigureAwait(false);
                    }
                    catch (global::System.Exception ex)
                    {
                        exceptions ??= new global::System.Collections.Generic.List<global::System.Exception>();
                        exceptions.Add(ex);
                    }
                }

                if (exceptions != null)
                    throw new global::System.AggregateException(exceptions);
            }
        }
    }
}
