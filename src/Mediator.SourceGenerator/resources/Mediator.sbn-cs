// <auto-generated>
//     Generated by the Mediator source generator.
// </auto-generated>

#pragma warning disable CS8019 // Unused usings

using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.Linq;

using SD = global::Microsoft.Extensions.DependencyInjection.ServiceDescriptor;

namespace Microsoft.Extensions.DependencyInjection
{
    /// <summary>
    /// DI extensions for Mediator.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    public static class DependencyInjectionExtensions
    {
        /// <summary>
        /// Adds the Mediator implementation and handlers of your application.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static IServiceCollection AddMediator(this IServiceCollection services)
        {
            {{~ if ServiceLifetimeIsScoped ~}}
            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.Mediator), typeof(global::{{ MediatorNamespace }}.Mediator), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ ServiceLifetime }}));
            {{ else }}
            services.Add(new SD(typeof(global::{{ MediatorNamespace }}.Mediator), typeof(global::{{ MediatorNamespace }}.Mediator), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IMediator), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.ISender), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            services.TryAdd(new SD(typeof(global::Mediator.IPublisher), sp => sp.GetRequiredService<global::{{ MediatorNamespace }}.Mediator>(), {{ SingletonServiceLifetime }}));
            {{~ end ~}}

            {{~ for message in RequestMessages ~}}
            {{ message.Handler.ServiceRegistrationBlock }}
            services.Add(new SD(
                typeof({{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}),
                sp =>
                {
                    return new {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}(
                        sp.GetRequiredService<{{ message.Handler.FullName }}>(),
                        sp.GetServices<{{ message.PipelineHandlerType }}>()
                    );
                },
                {{ message.Handler.ServiceLifetime }}
            ));
            {{~ end ~}}

            {{~ for handler in NotificationMessageHandlers ~}}
            {{ handler.ServiceRegistrationBlock }}
            {{~ end ~}}

            {{~ for message in NotificationMessages ~}}
            {{~ for registration in message.HandlerServicesRegistrationBlock ~}}
            {{ registration }}
            {{~ end ~}}
            {{~ end ~}}

            {{~ for handler in OpenGenericNotificationMessageHandlers ~}}
            {{ handler.OpenGenericServiceRegistrationBlock }}
            {{~ end ~}}

            return services;
        }
    }
}

namespace {{ MediatorNamespace }}
{
    {{~ for wrapperType in RequestMessageHandlerWrappers ~}}
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    internal sealed class {{ wrapperType.ClassHandlerWrapperTypeNameWithGenericTypeArguments }}
        where TRequest : class, global::Mediator.I{{ wrapperType.MessageType }}<TResponse>
    {
        private readonly {{ wrapperType.MessageHandlerDelegateName }} _rootHandler;

        public {{ wrapperType.ClassHandlerWrapperTypeName }}(
            global::Mediator.I{{ wrapperType.MessageType }}Handler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<{{ wrapperType.PipelineHandlerTypeName }}> pipelineBehaviours
        )
        {
            var handler = ({{ wrapperType.MessageHandlerDelegateName }})concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }
        
        public {{ wrapperType.ReturnTypeName }} Handle(TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    internal sealed class {{ wrapperType.StructHandlerWrapperTypeNameWithGenericTypeArguments }}
        where TRequest : struct, global::Mediator.I{{ wrapperType.MessageType }}<TResponse>
    {
        private readonly {{ wrapperType.MessageHandlerDelegateName }} _rootHandler;

        public {{ wrapperType.StructHandlerWrapperTypeName }}(
            global::Mediator.I{{ wrapperType.MessageType }}Handler<TRequest, TResponse> concreteHandler,
            global::System.Collections.Generic.IEnumerable<{{ wrapperType.PipelineHandlerTypeName }}> pipelineBehaviours
        )
        {
            var handler = ({{ wrapperType.MessageHandlerDelegateName }})concreteHandler.Handle;

            foreach (var pipeline in pipelineBehaviours.Reverse())
            {
                var handlerCopy = handler;
                var pipelineCopy = pipeline;
                handler = (TRequest message, System.Threading.CancellationToken cancellationToken) => pipelineCopy.Handle(message, cancellationToken, handlerCopy);
            }

            _rootHandler = handler;
        }

        public {{ wrapperType.ReturnTypeName }} Handle(in TRequest request, global::System.Threading.CancellationToken cancellationToken) =>
            _rootHandler(request, cancellationToken);
    }
    {{~ end ~}}

    /// <summary>
    /// Generated code for Mediator implementation.
    /// This type is also registered as a DI service.
    /// Can be used directly for high performance scenarios.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Mediator.SourceGenerator", "{{ GeneratorVersion }}")]
    public sealed partial class Mediator : global::Mediator.IMediator, global::Mediator.ISender, global::Mediator.IPublisher
    {
        private readonly global::System.IServiceProvider _sp;
        {{~ if ServiceLifetimeIsSingleton ~}}
        private readonly global::System.Lazy<DICache> _diCacheLazy;
        private DICache _diCache => _diCacheLazy.Value;
        {{~ else ~}}
        private readonly DICache _diCache;
        {{~ end ~}}

        /// <summary>
        /// Constructor for DI, should not be used by consumer.
        /// </summary>
        public Mediator(global::System.IServiceProvider sp)
        {
            _sp = sp;
            {{~ if ServiceLifetimeIsSingleton ~}}
            _diCacheLazy = new global::System.Lazy<DICache>(() => new DICache(_sp));
            {{~ else ~}}
            _diCache = new DICache(_sp);
            {{~ end ~}}
        }

        private {{ if ServiceLifetimeIsSingleton; "sealed class"; else; "readonly struct"; end; }} DICache
        {
            private readonly global::System.IServiceProvider _sp;

            {{~ if ServiceLifetimeIsSingleton ~}}
            {{~ for message in RequestMessages ~}}
            public readonly {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }} {{ message.HandlerWrapperPropertyName }};
            {{~ end ~}}
            {{~ else ~}}
            {{~ for message in RequestMessages ~}}
            public {{ message.HandlerWrapperTypeNameWithGenericTypeArguments }} {{ message.HandlerWrapperPropertyName }}
            {
                [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                get => _sp.GetRequiredService<{{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}>();
            }
            {{~ end ~}}
            {{~ end ~}}

            public DICache(global::System.IServiceProvider sp)
            {
                _sp = sp;

                {{~ if ServiceLifetimeIsSingleton ~}}
                {{~ for message in RequestMessages ~}}
                {{ message.HandlerWrapperPropertyName }} = sp.GetRequiredService<{{ message.HandlerWrapperTypeNameWithGenericTypeArguments }}>();
                {{~ end ~}}
                {{~ end ~}}
            }
        }

        {{~ for message in RequestMessages ~}}
        /// <summary>
        /// Send a message of type {{ message.RequestFullName }}.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public {{ message.AsyncReturnType }} {{ message.AsyncMethodName }}(
            {{ message.ParameterModifier -}}{{ message.RequestFullName }} message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            return _diCache.{{ message.HandlerWrapperPropertyName }}.Handle({{- message.ParameterModifier -}}message, cancellationToken);
        }
        {{~ end ~}}

        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
        private static void ThrowInvalidMessage(object msg) =>
            throw new global::Mediator.MissingMessageHandlerException(msg);

        /// <summary>
        /// Send request.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming request</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasRequests }}
            switch (request)
            {
                {{~ for message in IRequestMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(request);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(request);
            return default;
            {{ end }}
        }
        
        /// <summary>
        /// Create stream for request.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="request">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamRequest<TResponse> request,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamRequests }}
            switch (request)
            {
                {{~ for message in IStreamRequestMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(request);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(request);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Send command.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming command</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.ICommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasCommands }}
            switch (command)
            {
                {{~ for message in ICommandMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(command);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(command);
            return default;
            {{ end }}
        }
        
        /// <summary>
        /// Create stream for command.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="command">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamCommand<TResponse> command,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamCommands }}
            switch (command)
            {
                {{~ for message in IStreamCommandMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(command);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(command);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Send query.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming query</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask<TResponse> Send<TResponse>(
            global::Mediator.IQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasQueries }}
            switch (query)
            {
                {{~ for message in IQueryMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = Send({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Threading.Tasks.ValueTask<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(query);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(query);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Create stream for query.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="query">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<TResponse> CreateStream<TResponse>(
            global::Mediator.IStreamQuery<TResponse> query,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasStreamQueries }}
            switch (query)
            {
                {{~ for message in IStreamQueryMessages ~}}
                case {{ message.RequestFullName }} r:
                {
                    var task = CreateStream({{- message.ParameterModifier -}}r, cancellationToken);
                    return global::System.Runtime.CompilerServices.Unsafe.As<{{ message.AsyncReturnType }}, global::System.Collections.Generic.IAsyncEnumerable<TResponse>>(ref task);
                }
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(query);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(query);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Send message.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public{{ if HasAnyRequest; " async "; else; " "; end; }}global::System.Threading.Tasks.ValueTask<object> Send(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasAnyRequest }}
            switch (message)
            {
                {{~ for message in IMessages ~}}
                case {{ message.RequestFullName }} m: return await Send({{- message.ParameterModifier -}}m, cancellationToken);
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(message as global::Mediator.IMessage);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(message as global::Mediator.IMessage);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Create stream.
        /// Throws <see cref="global::Mediator.MissingMessageHandlerException"/> if no handler is registered.
        /// </summary>
        /// <param name="message">Incoming message</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Async enumerable</returns>
        public global::System.Collections.Generic.IAsyncEnumerable<object> CreateStream(
            object message,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasAnyStreamRequest }}
            switch (message)
            {
                {{~ for message in IStreamMessages ~}}
                case {{ message.RequestFullName }} m: return CreateStream({{- message.ParameterModifier -}}m, cancellationToken);
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(message as global::Mediator.IStreamMessage);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(message as global::Mediator.IStreamMessage);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Publish notification.
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish(
            object notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
        {
            {{- if HasNotifications }}
            switch (notification)
            {
                {{~ for message in NotificationMessages ~}}
                case {{ message.FullName }} n: return Publish<{{ message.FullName }}>(n, cancellationToken);
                {{~ end ~}}
                default:
                {
                    ThrowInvalidMessage(notification as global::Mediator.IMessage);
                    return default;
                }
            }
            {{ else }}
            ThrowInvalidMessage(notification as global::Mediator.IMessage);
            return default;
            {{ end }}
        }

        /// <summary>
        /// Publish notification.
        /// </summary>
        /// <param name="notification">Incoming notification</param>
        /// <param name="cancellationToken">Cancellation token</param>
        /// <returns>Awaitable task</returns>
        public global::System.Threading.Tasks.ValueTask Publish<TNotification>(
            TNotification notification,
            global::System.Threading.CancellationToken cancellationToken = default
        )
            where TNotification : global::Mediator.INotification
        {
            var sp = _sp;

            var handlers = sp.GetServices<global::Mediator.INotificationHandler<TNotification>>();

            var count = handlers.Count();
            if (handlers == null || count == 0)
                return default;
            else if (count == 1)
                return handlers.First().Handle(notification, cancellationToken);

            return Publish(notification, handlers, cancellationToken);

            async global::System.Threading.Tasks.ValueTask Publish(TNotification notification, global::System.Collections.Generic.IEnumerable<global::Mediator.INotificationHandler<TNotification>> handlers, global::System.Threading.CancellationToken cancellationToken)
            {
                // We don't allocate the list if no task throws
                global::System.Collections.Generic.List<global::System.Exception> exceptions = null;

                foreach (var handler in handlers)
                {
                    try
                    {
                        await handler.Handle(notification, cancellationToken).ConfigureAwait(false);
                    }
                    catch (global::System.Exception ex)
                    {
                        exceptions ??= new global::System.Collections.Generic.List<global::System.Exception>();
                        exceptions.Add(ex);
                    }
                }

                if (exceptions != null)
                    throw new global::System.AggregateException(exceptions);
            }
        }
    }
}
